---
layout: default
title: 한 권으로 읽는 컴퓨터 구조와 프로그래밍 4장
parent: 한 권으로 읽는 컴퓨터 구조와 프로그래밍
grand_parent: Reviews
nav_order: 4


---





<img src="https://github.com/terri1102/terri1102.github.io/blob/master/assets/images/review/slp1.jpg?raw=true" class="center" alt="slp1" style="zoom:33%;" />



# 4장 컴퓨터 내부 구조

: 컴퓨터 하드웨어는 어떻게 구성되는가



현대적 컴퓨터는 크게 메모리 memory(기억장치), 입력과 출력(I/O, input and output), CPU(central processing unit) 라는 세 가지 부분으로 나눌 수 있다. 



## 메모리

컴퓨터에서 조작할 비트들을 저장할 장소가 필요한데 이를 메모리라고 부른다. 메모리는 집이 늘어선 거리와 같다. 각 집에는 주소가 부여된다. 구체적인 주소에 있는 메모리를 가리킬 때 메모리 위치(memory location)라는 말을 사용한다. 



메모리의 기본 단위는 바이트이지만 32비트 컴퓨터는 보통 메모리를 4바이트 덩어리로 64비트 컴퓨터는 메모리를 8바이트 덩어리로 구성한다. 이렇게 덩어리로 구성하면 더 많은 데이터를 데이터 버스에 실을 수 있어 더 많은 데이터를 처리할 수 있다. 



* 메모리의 가격/성능 비율 : SRAM은 빠르고 비싸며 디스크는 저렴하지만 느리다.



* 엔디안(endian) : 각 단어의 가장 왼쪽 자리에 0번 바이트가 올수도, 가장 오른쪽 자리에 0번이 올 수도 있다. 리틀 엔디안은 가장 오른쪽에 0이 오며, 빅 엔디안은 가장 왼쪽에 0이 온다. 



## 입력과 출력

I/O에 연결되는 장치를 I/O 장치라고 부르며 이들은 컴퓨터 주변부에 위치하기 때문에 주변장치(peripheral device)라고 불린다. 



32비트나 64비트 컴퓨터가 나오면서 메모리 거리의 주소 수가 훨씬 많아졌고, 아무 메모리도 연관되지 않은 주소가 많아졌다. 따라서 이제는 메모리 거리 중 일부를 I/O 장치에 할당하는 것이 더 타당해졌다. 그리고 더 많은 부분을 연결이 한정적인 패키지에 구겨 넣어야 하기 때문에 I/O와 메모리가 같은 버스를 사용하는 것이 타당해졌다.



I/O 장치를 연결하는 방법: 설계상 표준 입력/출력 슬롯이 있어서 일관된 방식으로 I/O 장치를 연결할 수 있다. 아무도 사용하지 않는 주소 영역을 몇몇 사용 허가된 지역으로 나눈다. 각 슬롯을 차지한 장치는 자신에게 할당된 주소를 모두 사용할 수 있다.

![](http://www.mathcs.emory.edu/~jallen/Courses/355/Syllabus/6-io/mem-map-io.gif)



## 중앙 처리 장치(CPU)

중앙처리장치는 실제 계산을 처리하는 컴퓨터 부품.



### 1.산술 논리 장치(ALU, arithmatic logic unit)

CPU의 핵심부품. ALU는 산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있는 장치다.

<img src="https://image.slidesharecdn.com/csc1401-lecture03-computerarithmetic-arithmeticandlogicunitalu-150305012706-conversion-gate01/95/csc1401-lecture03-computer-arithmetic-arithmetic-and-logic-unit-alu-5-638.jpg?cb=1425518931" style="zoom:50%;" />

**피연산자(operand)**: 수를 표현하는 비트



**명령코드(opcode, operation code)**: 피연사자에 대한 ALU가 어떤 연산자(operator)를 적용할지 지정한다.



**결과(result)**: 피연산자에 연산자들을 적용한 결과



**조건코드(condition code)**: 결과에 대한 추가 정보

조건코드 레지스터(condition code register) 라는 조건 코드가 저장된다. 

레지스터는 메모리 거리가 아닌 다른 곳에 존재하는 메모리. 



**조건 코드 레지스터**

<br> 

* N 비트: 마지막으로 수행한 연산 결과가 음수인 경우 1로 설정

* Z 비트: 마지막 연산 결과가 0인 경우 1이 된다

* O비트: 마지막 연산에서 오버플로나 언더플로가 생긴 경우 1



| 명령코드 | 니모닉(mnemonic) | 설명                                    |
| -------- | ---------------- | --------------------------------------- |
| 0000     | clr              | 피연산자 무시. 결과의 모든 비트를 0으로 |

ALU는 실제로 셀렉터와 논리 게이트를 연결한 것





### 2. 시프트

**시프트 연산**: 왼쪽 시프트는 어떠 숫자의 모든 비트를 왼쪽으로 1비트씩 옮기고, 맨 왼쪽 비트는 버리고 (비트들이 밀려남에 따라) 비게 되는 가장 오른쪽 비트에 0을 넣는다. 어떤 수를 1비트 왼쪽으로 시프트하면 그 수에 2를 곱한 것과 같다. 오른쪽 시프트는 그 수를 2로 나누면서 나머지를 버리는 것과 같다.



왼쪽 시프트를 할 떄 사라지는 MSB값이나 오른쪽 시프트를 하면 사라지는 LSB 값은 조건 레지스터에 저장한다. 



**시프트 레지스터: **클록에 따라 내용을 1비트씩 시프트하는 시프트 레지스터를 플립플롭을 사용해 만들 수도 있다. 순차적인 시프트 레지스터는 1비트를 시프트할 때 한 클록이 필요하기 때문에 느리다. 



**배럴 시프터를 이용한 해결:** 한 비트당 하나의 셀렉터를 사용하는데 예를 들어 8비트 시프터를 만들면 여덟가지 가능한 모든 경우가 선으로 연결되어 있고 우리가 원하는 한 가지 경우를 선택할 수 있다.



### 3. 실행장치

컴퓨터의 실행장치(execution unit)은 제어 장치(control unit) 라고 알려져 있으며, 컴퓨터의 대장역할을 한다. 실행장치는 메모리의 정해진 장소에서 명령코드와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할지 알려주고 결과를 메모리에 돌려준다. 



실행 장치가 이런 일이 가능한 것은 메모리에서 명령어를 찾아서 작동하기 때문이다. 명령어(instruction)은 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴이다. 실행장치가 메모리에서 명령어를 가져와야 하는 위치는 프로그램 카운터(program counter)를 통해 알게 된다. 프로그램 카운터도 레지스터의 일종이며, 메모리와 별도의 특별한 곳에 위치한다. 



프로그램 카운터는 메모리의 위치를 가리킨다(reference) 실행 장치는 프로그램 카운터가 가리키는 주소에서 명령어를 읽어오고 이 명령어를 수행한 뒤에는 다음 명령어를 메모리의 다음 위치에서 가져올 수 있도록 프로그램 카운터가 증가(increment)한다.





## 명령어 집합

### 1. 명령어

명령어는 명렁코드, 두 피연산자, 결과라는 네 가지 필드로 나눌 수 있다.

| 명령코드       | 피연산자 B | 피연산자 A | 결과    |
| -------------- | ---------- | ---------- | ------- |
| 15, 14, 13, 12 | 11,10,9,8  | 7,6,5,4    | 3,2,1,0 |

여기서 문제는 결과와 피연산자 주소에 4비트밖에 쓸 수 없기 때문에 한계가 있다. 



DRAM 주소 지정 기법을 활용하면 주소 확장 레지스터(Address extension register)를 두고 별도의 명령어를 사용해 상위 주소를 지정한다. 



...이런 방법들에도 한계는 있다.



### 2. 주소 지정 모드

* 직접 주소 지정(direct addressing) :사용할 주소가 명령어에 직접 들어가 있음
* 간접 주소 지정(indirect addressing) : CPU는 명령어에 들어 있는 값을 피연산자 주소로 해서하지 않고, 피연산자 주소를 얻을 수 있는 메모리 위치를 가리키는 주소로 사용

* 즉시 주소 지정모드(immediate addressing mode) : 주소에 해당하는 비트를 그냥 값으로 간주한다. 
* 직접 주소 지정은 메모리에 두 번 접근해야 하기 때문에 즉시 주소 지정보다 느리다.



### 3. 조건 코드 명령어 

조건 코드를 다루는 명렁어는 cca라는 명령어와 누산기의 값을 조건 코드 레지스터에 복사하는 acc라는 명령어로 추가할 수 있다.



### 4. 분기 명령어

의사 결정을 내리고 코드 중 일부를 선택적으로 실행할 수 있는 프로그램을 위해서는 프로그램 카운터의 값을 변경할 수 있는 명령어가 필요하다. 이런 명령어를 분기 명령어라고 한다.



### 5. 최종 명령어 집합 구성

| 모드  | 명령코드    | 주소                |
| ----- | ----------- | ------------------- |
| 15,14 | 13,12,11,10 | 9,8,7,6,5,4,3,2,1,0 |



## 마지막 설계

### 1. 명령어 레지스터



### 2. 데이터 경로와 제어 신호



### 3. 데이터 흐름 제어



## RISC와 CISC 명령어 집합

RISC: 자주 쓰는 명령어만 모아둔 것. 연산 효율성 위해서.
