---
layout: default
title: 한 권으로 읽는 컴퓨터 구조와 프로그래밍 4장
parent: 한 권으로 읽는 컴퓨터 구조와 프로그래밍
grand_parent: Reviews
nav_order: 5


---



<img src="https://github.com/terri1102/terri1102.github.io/blob/master/assets/images/review/slp1.jpg?raw=true" class="center" alt="slp1" style="zoom:33%;" />



{:toc}



# 5장 컴퓨터 아키텍처와 운영체제

: 컴퓨터는 어떻게 프로그램과 메모리를 조직적으로 관리할까

이번 장의 내용은 멀티태스킹을 가능하게 하는 여러 방법들 설명이다.



**컴퓨터 아키텍처**: 컴퓨터의 여러 구성요소를 배치하는 방법



## 기본적인 구성 요소들

**대표적인 컴퓨터 구조**: 폰 노이만 구조, 하버드 구조

![](https://vivadifferences.com/wp-content/uploads/2019/10/Von-Neuman-Vs-Harvard-Architecture.png)

두 구조의 유일한 차이는 메모리 배열. 하버드 구조는 동시에 명령어와 데이터를 가져올 수 있어서 좀 더 빠르지만 두번째 메모리를 처리하기 위한 버스가 더 필요하다.



### 프로세서 코어

**CPU :** ALU, 레지스터, 실행장치의 조합

* **멀티프로세서(Multiprocessor) :** 여러 CPU를 활용하는 것

* **멀티코어(Multicore):** CPU는 1개인데 복수의 코어가 탑재되어 있음.

예전엔 CPU라고 부르던 것을 요즘은 **프로세서 코어**라고 부르고, 이런 코어가 여러 개 들어간 **멀티코어(multicore) 프로세서가** 이제 일반적으로 쓰인다.



### 마이크로프로세서와 마이크로 컴퓨터

**물리적인 패키징에 따른 구조 분류**

* **마이크로프로세서(microprocessor)**: 메모리와 I/O가 프로세서 코어와 같은 패키지에 들어 있지 않은 프로세서

* **마이크로컴퓨터(microcomputer)**: (=마이크로컨트롤러) 모든 요소를 한 칩 안에 패키징

칩 안에서 메모리가 차지하는 영역이 크기 때문에 일반적으로 마이크로프로세서보다 마이크로 컴퓨터가 덜 강력하다. 마이크로프로세서는 보통 큰 시스템에 들어가는 부품으로 쓰이고, 마이크로 컴퓨터는 식기세척기 등에서 쓰이는 (단일 칩으로 된) 작은 컴퓨터이다.



## 프로시저,  서브루틴, 함수

**함수(fuction, 또는 프로시저procedure나 서브루틴subroutine):** 코드를 재사용하는 주요수단.

**함수의 작동 과정:** 함수를 호출하는 부분에서 함수를 실행하고 프로그램 카운터의 값을 이용해서 다시 원래의 자리로 돌아온다. 함수를 실행한 다음에 돌아와야 하는 주소를 계산(반환return 주소)를 계산해야 하는데 이때 계산값을 누산기에 넣는 코드와 함수호출 코드도 고려해야한다.

|반환주소 저장|

|함수 파라미터 -> 누산기|

|함수로 분기| ------------------------------------------------> 함수 실행

​																								|

|함수 반환 뒤에 실행 계속 |						< --------간접분기(반환)

|반환 주소|



## 스택



스택은 나중에 들어온 것이 먼저 나가는 LIFO(Last in, First out)의 자료구조이다. 스택은 재귀함수가 제대로 작동하기 위해 반환주소, 지역변수를 저장하게 해주어 각각의 함수 호출이 서로 독립적이게 한다. 이렇게 함수가 호출될 때마다 스택에 저장되는 데이터의 모음을 스택 프레임(stack frame)이라고 한다.

> 한국어나 일본어는 스택 기반 언어다. 명사(목적어)를 스택에 넣고 그다음에 오는 동사는 스택에 있는 명사에 작용한다. <스타워즈>에 나오는 요다의 언어 습관도 이와 같은 패턴을 따른다.

* 수식 표기법
  * 중위 표기법(infix notation) : 연산자를 피연산자 사이에 넣음
  * 전위 표기법(prefix notation) : 연산자를 피연산자보다 앞에 쓴다. 괄호를 안 쓴다.
  * 역폴란드 표기법(RPN) : 연산자를 피연산자 뒤에 넣는다. 스택을 사용해 구현



## 인터럽트

작업이 이뤄지는 중간에 잠깐 중단(interrupt)시켜야 하는 외부의 요소에 대응하는 방법이 필요하다. 폴링(polling)은 프로세스를 아주 잘게 나누어서 작은 프로세스가 끝날 때마다 질문 분기를 거치게 한다. 하지만 요즘 프로세서는 대부분 인터럽트(interrupt)시스템이 들어간다. 

**인터럽트 시스템이 작동되는 방식:**

> CPU가 주의를 기울여야 하는 주변장치는 인터럽트 요청(interrupt request)을 생성한다.프로세서는 현재 실행 중인 명령어를 끝까지 실행한다. 그 후 현재 실행중인 프로그램을 잠시 중단시키고 인터럽트 핸들러(interrupt handler)라는 전혀 다른 프로그램을 실행한다. 인터럽트 핸들러가 필요한 작업을 다 마치고 나면 원래 실행 중이던 프로그램이 중단된 위치부터 다시 실행을 계속 한다.

**고려해야 할 요소:** 

1) 인터럽트에 대한 응답시간- 정해진 시간 안에 인터럽트 처리(인터럽트 서비스)해야 함

2) 인터럽트 시스템은 서비스 후 다시 원래 돌아오기 위해 현재 상태(state)를 스택에 저장

컴퓨터는 약속된 메모리 주소에 인터럽트 핸들러 주소를 저장해서 인터럽트 핸들러의 위치를 찾는다. 이 주소에는여러 인터럽트 벡터가 들어있다. 인터럽트 벡터에 저장된 주소를 살펴보고 그 주소로 옮긴다.(프로그램 카운터를 인터럽트 벡터에 저장된 값으로 설정함)

cf) 물리적(하드웨어) 인터럽트: 유닉스 운영체제는 시그널 메커니즘 제공. 최근 개발된 시스템들은 이를 이벤트라고 부른다.



## 상대 주소 지정

여러 프로그램을 동시에 실행하기 위해서 프로그램의 전환을 관리하는 프로그램이 필요한데, 이런 프로그램을 운영체제 또는 운영체제 커널이라고 한다. OS를 시스템 프로그램이라고 하고, 다른 프로그램은 사용자(user) 프로그램이나 프로세스(process)라고 부른다. 

OS는 타이머를 이용해 사용자 프로그램을 전환시켜 줄 때가 되었는지 판단한다. 이런 스케줄링방법을 시분할(time slicing)이라고 부른다. 시분할은 시간을 정해진 간격으로 나누고 정해진 시간 간격 동안 사용자 프로그램을 실행한다. 이 방법의 단점은 프로그램을 메모리로 불러와야 하기에 아주 느리다는 것이다. 이를 극복하기 위해 메모리에 각 프로그램별 다른 공간을 허용하면 실행이 더 빨라진다.

사용자 프로그램을 하나씩 메모리에 올리기 위해 **1. 인덱스 레지스터(index register)**를 추가해 해결하거나, **2. 상대 주소 지정(relative addresssing)을** 사용할 수 있다. 인덱스 레지스터를 사용하면 인덱스 레지스터의 값을 명령에 들어 있는 주소와 더해서 유효 주소를 계산한다. 상대 주소 지정은 명령에 들어있는 주소를 0부터 시작하는 위치로 해석하지 않고 명령어의 주소를 기준하는 상대적인 주소로 해석한다. 상대 주소 지정을 사용하면 프로그램을 메모리의 원하는 위치로 자유롭게 재배치(relocate)할 수 있다. 



## 메모리 관리 장치

백그라운드 실행: 사용자가 실행 중인 프로그램과 더불어 실행된다는 의미



인덱스 레지스터와 상대 주소 지정이 멀티 테스킹에 도움되지만 아직 부족하다. 

**메모리 관리 장치(MMU, memory management unit)**: 가상 주소(virtual address)와 물리 주소(physical address)를 분리해서 프로그램들을 분리한다. 

MMU는 가상 메모리 주소를 두 부분을 나눠서 주소의 하위(LSB쪽) 부분은 물리적 주소 범위와 같고, 상위(MSB쪽) 부분은 페이지 테이블(page table)이라는 RAM의 영역을 통해 주소를 변환(translation)한다. (프로그램의 가상 주소를 물리 주소로 변환)

MMU로 인해 폰 노이만 구조와 하버드 구조의 구분이 의미 없어졌다. 단일 메모리 버스만 사용하는 폰 노이만 구조의 시스템도 명령어 메모리와 데이터 메모리를 분리해 제공할 수 있다.

**페이지 폴트 예외(page fault) :** 스택 오버플로가 발생하면 스택 범위를 벗어나는 주소에 접근하므로 페이지 폴트가 발생하고 이 예외가 발생하면 OS는 실행 중인 프로그램을 중단시키는 대신 MMU가 추가 메모리를 할당하게 해서 스택 공간을 늘리고 사용자 프로그램 실행을 계속할 수 있다.

## 가상 메모리

OS는 희소한 하드웨어 자원을 사용하려고 경합하는 프로그램들 사이의 자원 분배를 관리한다. OS는 MMU를 사용해 사용자 프로그램에게 가상 메모리(virtual memory)를 제공한다. 

**요구불 페이징(demand paging)**: 요청 받은 메모리가 사용 가능한 물리적 메모리 크기보다 크다면 OS는 현재 필요하지 않은 메모리 페이지를 더 느리지만 더 용량이 큰 디스크로 옮긴다.(스왑 아웃, swap out) 스왑 아웃한 페이지에 프로그램이 접근하면 운영체제는 필요한 메모리 공간을 확보하고 요청 받은 페이지를 다시 메모리로 불러들인다.(스왑 인, swap in)

**스와핑(swapping, 스왑 인이나 스왑 아웃)** : 이런 방법을 통해 시스템 성능이 크게 저하되지만 메모리가 부족해서 프로그램을 실행하지 못 하는 것 보단 낫다. 최소 최근 사용(LRU, least recently used) 알고리즘을 이용하면 페이지 접근을 추적해서 스왑 아웃할 페이지를 결정하는데, 이는 최근에 가장 자주 사용된 페이지는 물리 메모리에 그대로 남겨두고 최근에 가장 덜 사용한 페이지를 스왑 아웃하는 것이다.



## 시스템 공간과 사용자 공간

시스템 공간과 사용자 공간을 분리해서, 일부 특권 명령어는 오직 시스템 모드에서만 실행할 수 있다. 트랩이나 시스템 콜 등의 특별한 명령어를 통해 사용자 모드에서 실행 중인 프로그램이 시스템 모드 프로그램에게 요청을 보낼 수 있다.



**장점:** 

-1.사용자 프로그램으로부터 운영체제를 보호하고, 사용자 프로그램을 다른 사용자 프로그램으로부터 보호

-2.사용자 프로그램이 MMU 등 몇몇 요소에 손을 댈 수 없기에 운영 체제가 프로그램에 대한 자원 할당을 제어함

## 메모리 계층과 성능

CPU의 속도와 메모리의 속도 차이로 인해 메모리 계층을 사용한다.

레지스터는 냉장고 같아서 공간이 많진 않지만 내용물에 빨리 접근 가능하다. 주 메모리는 가게와 같고, 대용량 저장 장치는 창고와 같다. 

| 메모리 계층 |
| ----------- |
| CPU         |
|레지스터 |
|L1 캐시 |
| L2 캐시 |
| L3 캐시 |
| 주 메모리 |
| 대량 저장 장치 |





## 코프로세서

프로세서 코어가 몇 가지 연산을 코프로세서(coprocessor)라는 더 단순한 회로에 위임하면 프로세서 코어가 일반적인 연산에 활용할 수 있는 공간을 더 확보할 수 있다.

일부 코프로세서는 다른 일은 처리하지 않고 데이터 복사만 담당하며, 이를 직접 메모리 접근(DMA, direct memory access) 이라 부른다. CPU는 DMA 장치에 귀찮은 일을 떠맡기고 유용한 연산을 더 많이 처리할 수 있다.



## 메모리상의 데이터 배치

메모리에 명령어만 담는 것이 아니라 데이터도 담는데, 이때 데이터는 정적 데이터이다. 정적이라는 의미는 프로그램을 작성할 때 얼마나 많은 메모리가 필요한지 알고 있다는 의미이다. 프로그램이 메모리를 사용하는 다른 방법은 방법은 동적(dynamic) 데이터이다. 동적데이터는 프로그램을 실행하기 전에는 크기를 알 수 없는 데이터를 말한다. 동적 데이터는 주로 정적 데이터가 차지하는 영역의 바로 위 여역에 쌓이며, 이를 힙이라고 부른다. 힙과 스택이 서로 충돌하지 않는 것이 중요하다.





## 프로그램 실행



***진입점(entry point)과 런타임 라이브러리(runtime library)**

프로그램에는 진입점이 있다. 진입점은 프로그램의 첫 번째 명령어가 위치한 주소를 뜻한다. 하지만 실제 프로그램이 실행될 때 가장 먼저 실행되는 명령어는 런타임 라이브러리에 있는 명령어이다. 런타임 라이브러리는 프로그램을 이루는 부분들이 하나로 합쳐져서 실행파일(executable)을 이룰 때 추가된다. 런타임 라이브러리는 메모리 설정을 책임지며 스택과 힙 영역을 설정하고, 정적 데이터에 위치한 데이터의 초깃값도 설정한다. 이런 값들은 실행 파일에 들어 있고 시스템에서 메모리를 할당받은 직후 실행 파일에서 메모리로 복사돼야 한다.



---



멀티 코어와 멀티 프로세서 차이: https://loinews.com/36
