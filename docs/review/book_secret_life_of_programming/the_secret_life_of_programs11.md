---
layout: default
title: 한 권으로 읽는 컴퓨터 구조와 프로그래밍 11장
parent: 한 권으로 읽는 컴퓨터 구조와 프로그래밍
Grand_parent: Reviews
nav_order: 11
use_math: true

---





{:toc}

# 11장 성능 향상을 위한 알고리즘 기법

계산을 간소화하는 프로그래밍 트릭



계산을 효율적으로하는 것보다 더 나은 것은 **계산을 아예 안 하는 것** : 지름길(shortcut)과 근삿값 계산(approximating)

따라서 계산 자원을 효율적으로 사용한다는 말은 필요보다 더 많은 계산을 수행하지 않는 것을 뜻함.



## 표 찾기

매번 계산하기보다는 자주 사용하는 결과를 미리 계산해서 반복 사용하는 것이 합리적.



### 변환

A/D변환기가 10비트값을 생성하고 온도는 8비트로 충분하다고 하면 모든 계산을 없애기 위해서 1,024바이트짜리의 표가 있으면 됨



### 텍스처 매핑(texture mapping)

텍스처 매핑은 벽 등 3차원 물체의 표면을 표현하기 위해 직접 표면의 질감을 계산해 생성하는 것보다 이미지를 벽을 표현하는 물체(3차원 모델)의 표면에 그리는 편이 훨씬 더 적은 계산이 필요하다는 것에서 착안되었음.



뷰포인트(viewpoint, 시점)가 텍스처에서 멀어지면 인접한 픽셀을 서로 합쳐서 평균을 내야 함

MIP 매핑: multum in parvo : 많은 것을 작은 공간에 넣음

![slp16]

벽돌 텍스처로부터 MIP 맵을 만들려면...픽셀은 3 가지 8비트값으로 이뤄짐- 미사용 공간(전체의 1/4)에 1/4크기 복사본의 1/4 크기의 복사본을 이 공간에 넣을 수 있다. 

자주 사용할 정보를 미리 계산해두는 것(저해상도의 텍스처 등)은 루프 불변값 최적화와 비슷하다.



### 문자 종류 판별(character classification)

문자 종류 판별: 어떤 글자가 숫자, 문자 등 어떤 분류에 속하는지 판별하는 문제, 어휘 분석에서 중요한 부분

유용한 공통함수를 라이브러리에 넣자고 제안. 예를 들어 if 문 대신 표를 써서 루틴(함수나 프로시저 의미)을 구현. 표는 문잣값을 인덱스로 사용하고, 표의 각 원소의 비트는 대문자, 소문자, 숫자 등 문자의 여러 가지 특성을 표현했음.



* 매크로(macro)는 왼쪽의 코드를 오른쪽의 코드로 바꿔치기해주는 프로그램 언어 구성요소임. 코드가 작을 때는 함수를 쓰지 않고 매크로를 쓰면 함수 호출과 반환에 따른 부가 비용을 줄일 수 있어 유용. 





## 정수를 사용한 계산 방법

정수 덧셈이나 뺄셈은 (곱셈, 나눗셈, 부동소수점 연산보다) 비용이 쌈 -> 더 비싼 연산을 피할 수 있는 방법 찾기



여기서는 캔버스 '모눈종이'를 예시로 설명할 것이다. 캔버스 '모눈종이'는 표준적인 직교 좌표계(Cartesian coordinate system)를 사용하지 않기 때문에 우리에게 익숙한 좌표계로 바꾸기 위해 변환을 해야한다. 모든 (x,y) 좌표에 대해 다음 식과 같은 변환(transformation)을 적용해 (x',y')로 변환해준다.(이를 아핀변환(affine)이라고 함)

* affine 변환: [아핀 변환](https://kr.mathworks.com/help/images/ref/affine2d.html)은 점, 직선, 평면을 보존하는 선형 매핑 방법입니다. 아핀 변환 후에도 평행한 선들은 평행한 상태로 유지됩니다. 아핀 변환 기술은 이상적이지 않은 카메라 각도에서 발생하는 [기하학적 왜곡이나 형태 변형](https://kr.mathworks.com/help/images/geometric-transformations.html)을 보정하는 데 주로 사용됩니다.

  출처: https://kr.mathworks.com/discovery/affine-transformation.html

  아핀 공간은 벡터 공간과 달리 방향, 크기에 더불어 "위치"까지 존재한다. 위치변환(translation)은 선형변환이 아니기 때문에 행렬의 곱셈으로 표현할 수 없어서 다른 변환들과 조합을 이루지 못한다.(선형성이 깨진다.) 하지만! 위치변환도 행렬의 곱셈으로 표현하는 것이 가능하다. 이는 현재 공간에서 차원을 하나 더 늘리면 가능하다. 3차원 공간의 아핀 변환을 4차원 공간의 선형 변환 행렬로 나타낼 수 있다. 이를 아핀 변환 행렬이라고 부른다. 

  요약: 3차원 공간은 아핀 공간이다. 점들을 변환하는 것은 아핀 변환이다. 점을 변환할 때 점 자체를 변환하지 않고 원점에서 그 점을 향하는 벡터를 선형 변환한다. 그 값이 점을 변환한 값과 같아진다. 모든 아핀 변환은 차원이 하나 확장된 공간의 선형 변환으로 바꿀 수 있다. 아핀 변환 행렬을 적용하려면 차원을 하나 확장해야 한다. (x,y,z,w)(단, w=1). 행렬의 결과에서 (x,y,z,w) 중 w를 빼ㅕㄴ 변환이 적용된 (x,y,z)가 나온다.

  출처 : https://luv-n-interest.tistory.com/810

$$
x' = Ax+By+C \\
y' = Dx+Ey+F
$$

아핀 변환의 종류: C와 F는 평행이동(translation)에 쓰이고 A와 E는 크기변환(scaling)에 기여하고, B와 D는 회전(rotation)에 기여한다. 이들을 행렬 형태로 표현하는 경우가 많다. 

해상도(resolution): 인치당 픽셀 수



### 직선

대각선을 긋고 싶을 때 원을 그려서 원 위의 점을 찍어서 대각선을 그리는 것을 생각해볼 수 있다. 이때 대각선 쪽의 픽셀이 더 멀리 떨어져 있으므로 빛의 밀도도 줄어들어 수평선보다 덜 밝아 보인다. 이를 최소화하기 위해 픽셀 모양을 조정한다.

**잭 브렌슨햄의 점진적 계산 알고리즘:** 부동소수점 계산없이 선을 그리는 방법 

x가 변할 때마다 y를 계산하여 기울기를 매번 더하기만 하면 곱셈을 없앨 수 있음

```javascript
var y = 0;

canvas.fillStyle = "rgb(0, 0, 0)"

for (var x = 0; x <= width; w++) { 
	canvas.beginPath();
	canvas.arc(x, Math.round(y), 0.15, 0, 2 * Math.PI, 0);
	canvas.fill();
	y = y + m;}
```

기울기가 분수이기 때문에 부동소수점 연산이 필요하지만, 나눗셈을 덧셈과 뺄셈으로 대신할 수 있다. 결정 변수(decision variable)로 d를 만들고, 매 반복 시 △y를 더한다. d ≥ △x인 동안 y값을 증가시킨다. 그리고 △x를 d에서 뺀다.

중간에 있는 픽셀에 점을 찍고 싶은 경우 d의 초깃값을 1/2m으로 설정하면 되며, 정수 연산으로 하려면 2를 곱해 분수를 없애면 된다.



### 곡선 다루기

타원을 이용해서 곡선 그리기
$$
타원: \frac{x^2}{a^2}+\frac{y^2}{b^2} = 1
$$
![slp17]

현재 까만점에 있을 때 세 가지 가능한 위치에서 식의 값을 계산하고, 그중 0에 가장 가까운 점을 택해보자.

A = b^2, B=a^2로 정의하면 이 타원의 식은 아래와 같다.
$$
Ax^2 + By^2 - AB
$$
우리가 (x,y)에 있다면 다음 점은 위의 식을 0에 더 가깝게 만드는 x,y이다. 이를 곱셈 없이 계산해보자.
$$
d_{x+1}= A(x+1)^2+By^2-AB
$$
이 값에서 원래의 식을 빼면 x와 x+1일 때 (d 공식으로 계산한) 거리의 차이를 구할 수 있으며, 이를 dx라고 하자.
$$
dx = 2Ax+A
$$
d에 dx를 더하면 d_{x+1}이 된다.
$$
dx_{x+1} = 2A(x+1) +A) \\
dx_{x+1} = 2Ax+2A+A
$$
이제 dx_{x+1}에서 dx를 빼서 둘의 차이를 구하면 d2x는
$$
d2x = 2A
$$
d2x는 상수이므로 곱셈없이 d를 구할 수 있다.
$$
2A_{x+1} = 2Ax+d2x
$$
수직 방향의 좌표는
$$
dy = -2By+B \\
d2y=2B
$$


### 다항식

점진적으로 차이를 계산하는 방식을 임의의 다항식으로 확장할 수도 있다.



## 재귀적 분할

최소한의 작업으로 원하는 목적을 달성하는 방법



### 나선

원하는 위치에 점들을 찍은 후 이 점들이 충분히 가까운지 판단하고 가깝지 않으면 선을 긋는 등 재귀 분할을 수행하는 식으로 나선을 그릴 수 있다. 



### 구성적인 기하

쿼드트리: 공간을 분할하는 계층적인 매커니즘. 재귀를 활용한 데이터 구조

쿼드트리를 이용해서 게스킷을 그리는 연산을 수행할 때 노드를 병합하면 트리가 메모리를 더 적게 사용할 뿐만 아니라, 트리 깊이가 낮아지면서 트리에 대해 수행하는 여러 연산도 빨라진다. 

이런식으로 복잡한 3차원 물체를 만드는 기법을 구조적 입체 기하(constructive soilid geometry)라고 하며, 2차원 픽셀에 대응하는 3차원 요소는 복셀(voxel)이라고 부른다.



### 시프트와 마스크

쿼드트리의 단점으로 (화면상 인접해보이는) 데이터가 메모리에서 분산된다는 점을 들 수 있다.(쿼드트리의 참조 지역성은 형편없음) 

> 디스플레이 메모리의 구조는 하드웨어에 의해 결정된다. 래스터의 각 줄은 한 번에 하나씩 정해진 순서대로 화면에 표시된다. 래스터의 한 줄을 스캔 라인(scan line)이라고 부르고, (화면에 표시할) 스캔 라인을 모아둔 데이터를 프레임 버퍼(frame buffer)라고 부른다.

프레임 버퍼에서 이 영역의 비트를 해제(0으로 만듦)해야 하며, 좌표와 쿼드트리 사각형의 크기를 사용해 마스크를 만든다. 이 마스크를 영향받는 모든 줄에 AND 할 수 있다. 비용은 한 줄당 두 번 메모리 접근(읽기, 쓰기) 



## 계산을 회피하는 그 밖의 수학적 기법들

### 멱급수 근삿값 계산

사인함수 계산하는 방법으로 테일러 급수(Taylor series)가 있음.
$$
sin(x) = x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\frac{x^9}{9!}
$$
항의 개수를 늘릴 수록 테일러 급수가 이상적인 사인 함수에 더 가까워 진다. product이라는 변수의 값을 x의 값으로 초기화하고, -x^2을 미리 계산해두면, 매번 다음 항을 구할 때는 product에 -x^2을 곱해서 rpoduct에 저장하면 곱셈 횟수를 줄일 수 있으며, 모든 분모는 상수이므로 미리 표에 저장하고 지수를 인덱스로 사용한면 연산을 줄일 수 있다.



### CORDIC 알고리즘

정수 산술 연산을 사용해 삼각함수와 로그함수를 계산하는 방법.

단위 원(unit circle)의 화살표 머리가 가리키는 지점의 x와 y 좌표는 해당 각의 사인값과 코사인값이다. 우리가 원하는 것은 원래의 위치로부터 x축을 기준으로 화살표를 조금씩 회전시켜서 원하는 각이 되면 좌표를 얻는 것이다.

**회전 모드의 CORDIC 알고리즘**
$$
x' = x * cos(\theta)-y*sin(\theta)\\
y' = x * sin(\theta)+y*cos(\theta)
$$
이를 탄젠트를 이용해서 다시 써보면
$$
\tan(\theta)=\frac{sin(\theta)}{cos(\theta)}
$$
이기에 
$$
x' = cos(\theta) \begin{bmatrix} x \frac{cos(\theta)}{cos(\theta)}-y\frac{sin(\theta)}{cos(\theta)}\end{bmatrix} =cos(\theta)\begin{bmatrix} x-y*tan(\theta) \end{bmatrix}\\
y' = cos(\theta) \begin{bmatrix} x \frac{sin(\theta)}{cos(\theta)}+y\frac{cos(\theta)}{cos(\theta)}\end{bmatrix} =cos(\theta)\begin{bmatrix} x*tan(\theta) +y \end{bmatrix}
$$
이다. 이 식을 이용해서 회전을 통해 식을 간소화할 수 있다.
$$
x_3 = C-\frac{C}{2}+\frac{\frac{C}{2}+C}{4}=0.531 \quad C:x_0 \\
x_3 = -\frac{C-\frac{C}{2}}{4} +\frac{C}{2}+ C=0.834 \quad C:x_0
$$




**벡터링 모드의 CORDIC 알고리즘**

회전모드와 반대로 원하는 각도의 벡터에서 시작해서 x축으로 뻗은 벡터(각도가 0)에 도달할 때까지 회전을 시킨다. 



## 무작위성과 관련 있는 예제들

의사 난수성(pseudorandomness)을 활용한 근삿값 계산



### 공간을 채우는 곡선

자기 유사성(self-similarity): 멀리서 보나 가까이 다가가서 보나 곡선이 비슷한 것. 프랙탈(fractals)이라는 집합의 부분집합임. 



### L 시스템(L-systems)

L 시스템(=린덴마이어 시스템, 생성 문법(production grammar))

매치될 패턴을 기술하는 것이 아니라 곡선 규칙에 사용한 규칙은 어떤 패턴을 만들어낼지 기술하는 것.





### 스토캐스틱 기법

스토캐스틱은 랜덤한 것과 비슷



### 양자화(quantization)

원래 이미지에 있는 색에 대해 변환될 이미지에서 쓸 수 있는 색을 할당하는 것. 256가지 값을 두가지 값에 매핑하는 것.

임계화(thresholding) : 어떤 한곗값을 정하고 그보다 더 밝은 값을 흰색으로, 그보다 더 어두운 값을 검은색으로 지정하는 방식

디더링(dithering): 이미지를 여러 크기의 점으로 분해하는 것. 디더링 알고리즘으로 바이어 필터가 있다.







