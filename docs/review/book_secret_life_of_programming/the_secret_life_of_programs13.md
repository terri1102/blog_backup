---
layout: default
title: 한 권으로 읽는 컴퓨터 구조와 프로그래밍 13장
parent: 한 권으로 읽는 컴퓨터 구조와 프로그래밍
grand_parent: Reviews
nav_order: 13
use_math: true

---



<img src="https://github.com/terri1102/terri1102.github.io/blob/master/assets/images/review/slp1.jpg?raw=true" class="center" alt="slp1" style="zoom:33%;" />

{:toc}

# 13장 컴퓨터 보안



## 보안과 프라이버시 개요

### 위협 모델(threat model)

보안은 위협 모델에 따라 상대적이며, 보안이 필요한 대상 목록과 각 보안 대상에 가해질 수 있는 공격을 열거해서, 이런 공격을 방어하는 방법을 설계할 수 있게 한다. 



### 신뢰

위협 모델을 정할 때 신뢰할 대상을 정해야 한다. 컴퓨터 보안에서 '신뢰'는 선택할 수는 없지만 의존해야 하는 대상을 가리킨다.

**신뢰 위반 유형**

* 의도적(deliberate) : 사용자가 실수로 설치한 것이 나닌 컴퓨터 제조사가 설치한 멀웨어(malware)
* 무능(incompetent) : 패스워드를 하드코딩하는 등의 신뢰위반
* 부정직(disingenuous) : 클렙토그래피(kleptography) 등 공격자가 비밀리에 안전하게 정보를 빼낼 수 있는 여러 수단.



### 물리적 보안

**공격 표면(attack surface)** : 공격의 대상. 예를 들어 사물함의 공격 표면으로는 사물함의 문, 번호 자물쇠, 번호 자물쇠 가운데의 열쇠 구멍이 있다.

**백도어(back-door)**: 우리가 제어할 수 없지만 내부에 접근할 수 있는 방법



### 통신 보안

**인증(authentication)** : 내용을 전달할 상대가 우리가 의도한 상대인지 확인하는 것.

**진본성(authenticity)** : 정보가 진짜인지를 나타내는 것.

**중간자 공격(man-in-the-middle-attack)** : 두 당사자의 중간에 공격자가 들어가서 통신을 가로채거나 변경하는 상황

**크립토그래피(cryptography)** : 송신자와 수신자만 아는 비밀 코드(secret code)를 사용해 암호화(encrypt)해서 보내면 수신자는 비밀 코드를 사용해 암호화된 메시지를 복호화(decrypt)한다.



### 모던 타임즈

현대의 공격들: DDos, Proxy, 사회적 공격

**DDos(분산 서비스 거부 공격)** : 많은 사람들이 협력해서 공격

**프록시 공격:** 공격자들은 몇몇 기계에 침입해서 자신의 소프트웨어(멀웨어)를 설치하고, 다른 기계들이 더러운 일을 하게 함.

**사회적 공격:** 트릭을 써서 사용자가 자신의 컴퓨터에 소프트웨어를 직접 설치하게 만드는 방법



### 사회적 맥락

보안의 두 가지 축: 1) 튼튼한 보안을 구축하기 위한 기술 2) 개인의 보안과 사회 전체의 보안 사이의 트레이드 오프



### 인증과 권한부여

**인증(authentication)** : 어떤 사람이나 대상이 실제로 그 사람이나 대상임을 증명하는 과정

**권한부여(authorization)** : 제대로된 '자격증명(credential)'을 제공하지 않는 사람에게 접근을 제한하는 것.



## 크립토그래피

크립토그래피를 사용하면 송신자가 통신 내용을 뒤죽박죽으로 만들어서 정해진 수신자만 디코딩하도록 송신할 수 있다. 크립토그래피는 보안과 프라이버시를 위해 중요하고 데이터의 진실성을 증명할 수 있다.

### 스테가노그래피

스테가노그래피(steganography): 어떤 내용을 다른 내용 속에 감추는 방식. 송신자와 수신자 사이에 연결의 자취가 남지 않기 때문에 비밀리에 통신하기 좋은 방법이다. 기술적으로는 크립토그래피가 아니나 암호화와 비슷한 역할을 한다. 많은 광고회사에서 개별 사용자를 식별가능한 URL이 링크된 단일 픽셀 이미지를 웹페이지에 포함시킨다. 



### 치환 암호

각 문자를 다른 문자로 변환하는 표를 만들고 이를 이용해서 암호화하고, 이를 참조해 역방향으로 복호화한다. 이런식으로 암호화와 복호화에 같은 암호를 사용하는 경우를 대칭 코드라고 부른다. 치환 암호는 통계를 이용해서 쉽게 깰 수 있다. 영어에서는 e,t,a,o,n의 순서로 자주 쓰이는 문자이기에 문자의 빈도를 이용해서 해독한다.



### 전치 암호

문자의 위치를 뒤섞어서 인코딩하는 방식이다. 



### 더 복잡한 암호

글자를 수치로 바꾸고 수에 대해 수학적인 연산을 수행한 다음, 이렇게 변환된 수를 다시 글자로 바꾸는 방식 등 복잡한 방식들이 사용되고 있다.



### 일회용 패드

일회용 패드(one-time pad) 가장 안전한 암호화 방식으로 중복되지 않는 유일한 치환 암호들의 모음으로 각 치환 암호 코드를 단 한 번만 사용했다. 하지만 패턴 반복을 피하려면 패드가 길어야 하고 송신자와 수신자가 동기화되어 있어야 한다는 등의 문제가 있다.



### 키 교환 문제

대칭 암호 시스템은 통신의 양 당사자가 같은 키를 사용해야 하기 때문에 중간자 공격에 취약하다.



### 공개키 암호

공개키 암호(public key crptography)는 지금까지 논의한 여러 문제 중 상당수를 해결해준다. 공개키 암호에서는 서로 연관된 키 쌍을 사용한다. 대칭키 암호와 달리 공개키 암호에서는 누구에게나 알려져 있는 키를 공개키(public key)라고 부르고, 수신자만 알고있어야 하는 키를 비밀키(private key)라고 부른다. 공개키로 암호화한 암호문은 비밀키로만 복호화할 수 있다. 이런 비대칭 시스템이로 키 교환 문제를 해결할 수 있다. 

공개키 암호는 트랩도어 함수에 의존한다. 트랩도어 함수는 한 방향으로는 계산하기 쉽지만 비밀 정보를 알지 못하면 반대쪽 방향으로 계산이 어려운 함수를 뜻한다. 공개키 암호의 아이디어는 트랩도어 함수를 계산할 수 있는 정보를 공개키로 사용하고, 트랩도어 함수를 쉽게 풀 수 있게 해주는 비밀 정보를 비밀키로 사용하는 것이다. 메시지를 공개키를 사용해 트랩도어 함수로 암호화하면 트랩도어 함수의 특성상 비밀키를 모르는 사람들이 평문을 알아내기는 어렵지만, 비밀키를 아는 사람은 쉽게 트랩도어를 풀어서 평문을 얻을 수 있다. 공개키 암호화 방식을 이용한 알고리즘으로 RSA 알고리즘이 있다. 



### 전방향 안전성

대칭 암호 세션 키를 실제 통신에 사용할 경우, 키를 발견하면 모든 메시지를 읽을 수 있다는 문제가 있다. 이를 피하는 방법이 전방향 안전성(forward secrecy)로 각 메시지마다 세션 키를 새로 만들어서 키를 알아내도 메시지를 하나만 풀 수 있게 된다.



### 암호학적 해시 함수

암호학적 해시 함수의 핵심 특성은 이들이 단방향 함수라는 것이다. 단방향이라는 말은 입력에서 해시값을 만들어내기는 쉬워도 해시에서 입력을 만들어낼 수는 없거나 만들어내려면 비용이나 시간이 많이 들어서 비실용적이라는 뜻이다. 또 다른 특성은 차이가 조금 있는 여러 입력 데이터에 암호학적 해시 함수를 적용해 만든 해시값들은 서로 연관관계가 없어야 한다는 특성이 있다. 현재 SHA 알고리즘을 변형한 다른 해시 알고리즘이 많이 쓰이고 있다.



### 디지털 서명

크립토그래피를 사용하면 디지털 서명(digitial signature)를 통해 데이터가 진본임을 검증할 수 있다. 디지털 서명은 정합성, 부인방지, 인증을 제공한다. 

* 정합성(integrity) 검증 : 메새지가 변조됐는지 검증할 수 있다는 것. 데이터의 암호학적 해시값을 계산해 데이터 뒤에 추가함으로써 이뤄진다.
* 부인방지(nonrepudiation) :  메시지를 보낸 사람이 메시지의 유효성을 부인하거나 반박할 수 없도록 보장하는 개념
* 인증(authentication) : 수신자는 공개키와 서명한 사람의 비밀키가 서로 되어 있음을 알고 있기 때문에 메시지에 서명한 사람을 확신할 수 있고, 변조가 되지 않았음은 해시값으로부터 확인할 수 있기 때문에, 수신자가 받은 메시지가 원본과 같은 메시지라는 사실을 확인할 수 있다.



### 공개키 인프라

공개키 인프라스트럭처(public key intrastructure) : 공개키가 정말 올바른 송신자한테서 온 것이라는 것을 증명하기 위해 이 인프라에는 신뢰할 수 있는 제 3자인 인증기관(CA, certificate authority) 가 있어서 키가 어떤 당사자 것임을 인증해준다. 



### 블록체인

장부는 레코드로 구성되며, 블록체인에서 장부 한 줄에 해당하는 내용은 블록(block)이며 새 블록을 만들 떄는 이전 블록에 대한 암호학적 해시와 블록 생성 시간을 추가한다. 따라서 블록 n의 내용을 변경하면 그 블록의 해시가 바뀌기 때문에 블록 n+1에 저장된 해시와 일치하지 않게 된다. 



## 보안을 위한 소프트웨어 예방 조치

* 올바른 대상을 보호하라 : 모든 대상을 안전하게 보호하려 하지 마라
* 로직은 세 번 체크하라
* 오류를 검사하라
* 공격 표면을 최소화하라 : 소프트웨어에 새로운 기능을 추가할 때마다 새로운 공격 표면이 추가됨
* 경계 내부에 머물러라 : 소프트웨어가 데이터 메모리 경계를 체크하지 않고 데이터를 덮어쓰는 버퍼 오버플로를 조심하라
* 좋은 난수를 생성하기는 힘들다
* 네 코드를 알라 : 서드파티 코드를 사용할 때 제품에 사용되지 않는 코드 확인
* 극단적인 영리함은 독이다 : 서드파티 코드의 이상하고 영리한 기능 피하기
* 눈에 보이는 것을 이해하라
* 과다수집하지 마라
* 모아두지 마라
* 동적 메모리 할당의 함정 : 보안이 필요한 경우 realloc 대신 malloc으로 새 메모리를 할당하고 이전 데이터를 새 블록에 복사한 다음, 민감한 데이터를 덮어써 지우고 free로 해제하라.
* 가비지 컬렉션의 함정 : 민감한 정보를 덮어쓰는 대신 새로운 문자열을 할당한 다음 민감한 정보가 담긴 문자열은 가비지 컬렉션이 가능한 문자열로 분류하기에 민감 정보가 지워지지 않는다.
* 코드 역할을 하는 데이터를 조심하라. ex) SQL





