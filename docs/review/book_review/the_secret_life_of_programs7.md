---
layout: default
title: 한 권으로 읽는 컴퓨터 구조와 프로그래밍 7장
parent: 한 권으로 읽는 컴퓨터 구조와 프로그래밍
Grand_parent: Book Reviews
nav_order: 7


---





{:toc}

# 7장 데이터 구조와 처리

어떻게 해야 프로그램에서 데이터를 잘 구성하고 처리할까



메모리 장치를 읽고 쓰는 방식이 각 메모리 장치의 속도에 영향을 끼침 -> 메모리 시스템의 성질을 염두에 두고 데이터를 조직적으로 잘 정리하면 더 나은 성능을 얻을 수 있음

 :package: ​**데이터 구조(data structure)** : 데이터를 조직화하는 표준적인 방법. 데이터 구조 중 상당수는 여러 유형의 메모리를 더 효율적으로 사용하기 위해 존재한다. 

**참조 지역성(locality of reference)** : "필요한 데이터를 (메모리에서) 서로 근처에 유지하라. 금방 사용할 데이터라면 더 가까운 곳에 저장하라. "



## 기본 데이터 타입(primitive data type)

기본 데이터 타입의 두 측면: 크기(비트수)와 해석(부호가 있는지, 없는지, 부동소수점 수인지 문자인지, 포인터인지)

:point_right: ​**포인터(pointer)**: 단지 컴퓨터 아키텍처에 따라 결정되는 크기의 부호가 없는 정수에 불과하며, 정숫값이 아니라 메모리 주소로 해석됨. 간접 주소 지정이 포인터

일부 언어는 잘못된 포인터 사용으로 인한 오류를 막기 위해 참조(reference)라는 더 추상적 개념 사용하기도함. 자바 등

포인터를 무분별하게 정수와 바꿔 쓰면 이식성(portability)이 떨어짐



## 배열

**배열(array)**을 아파트라고 한다면 호수는 **인덱스(index)**, 각각의 집은 **원소(element**)라고 할 수 있다.

| 0    | 1    |
| ---- | ---- |
| 2    | 3    |
|4|5|
|6|7|

위의 배열은 4개의 16비트로 이루어진 1차원의 배열이다. 각 원소는 8비트 바이트 2개가 들어 있음

**참조 지역성(locality of reference)** : 열 인덱스가 바뀔 때보다 행 인덱스가 바뀔 때 더 많은 이동이 이루어진다. 열 인덱스가 1바뀌면 인접한 메모리 위치에 있는 원소로 이동하지만, 행 인덱스가 1바뀌면 인접한 행으로 이동해야 하기 때문에 연속적인 메모리 공간상으로는 배열의 열 개수만큼 떨어져 있는 메모리 위치에 있는 원소로 이동해야 한다.



## 비트맵(bitmap)

:world_map: **비트맵** : 비트의 배열 

**비트맵 기본 연산 **: 비트 설정(set), 비트 지우기(clear), 비트가 1인지 검사, 0인지 검사

특정 비트가 들어 있는 바이트 찾기 : 정수 나눗셈의 나머지를 통해서 찾음. (배럴 시프터가 있으면 값을 시프트함으로써 이를 빠르게 계산 가능) -> 비트 위치에 대한 **마스크**를 만듦(들여다볼 수 있는 구멍이 있는 비트 패턴)

* 비트 설정하기: 비트들index = 비트들index OR 마스크



## 문자열(string) ​​

:abc: **문자열: ​**여러 문자로 이뤄진 시퀀스 

배열과 마찬가지로 문자열을 연산할 때도 그 길이를 알아야 한다. 가변 문자열을 사용시 큰 배열을 사용하는 경우가 많지만, 배열 크기는 문자열 길이와 관계가 없기 때문에 문자열 길이를 추적할 방법이 필요하다. 

1. 문자열 안에 길이 저장

   * 장점: 제대로 작동
   * 단점: 문자열 길이 255자로 제한, 문자열은 바이트라서 메모리 정렬(alignment)이 그때그때 다를 수 있음->하지만 길이를 저장하기 위해 몇 바이트를 할당하는 경우 길이 정보는 반드시 올바른 메모리 정렬 경계에 있어야 함

2. 문자열 터미네이터: C는 문자열을 위한 전용 데이터 타입을 제공하지 않고, 1차원 바이트 배열을 사용. (1바이트 1 char) 문자열의 길이를 저장하는 대신 문자 배열에 있는 문자열 데이터의 끝에 바이트를 하나 추가하고 NUL을 넣는다.(0을 문자열 터미네이터로 사용)

   * 장점: 저장이 쉬움. 문자열의 끝까지 각 문자 출력시 부가 비용이 들지 않음
   * 단점: 문자열 길이 알아내는 것이 터미네이터 발견시까지 하나하나 스캔해야하는 노가다..., 문자열 중간에 NUL을 못 넣음

   

## 복합 데이터 타입

**구조체(structure)** : 사용자가 원하는 대로 만들 수 있는 데이터 타입

**멤버(member)** : 구조체 안에 있는 여러 방

|       |         |         |      |      |       |      |    
| ----- | ------- | ------- | ---- | ---- | ----- | ---- | 
| hours | minutes | seconds | yea- | rs   | month | day  |      

->위는 일시를 표현하는 구조체. 월,일,시,분,초는 1바이트인 unsigned char를 사용했고, 연도를 저장하기 위해 2바이트인 unsigned short를 사용했다. 

**편의 문법(systactic sugar)** : 프로그램을 더 쉽게 만들어주는 비필수적 요소 ex) a+=1

메모리 정렬도 지켜야 하기에 패딩을 필요한 만큼 추가해서 경계에 걸치지는 문제를 해결할 수 있다.

실제로 날짜와 시간을 다룰 때는 유닉스 에포크(1970년 1월 1일)를 기준으로 몇 초가 지났는지를 표현하는 32비트 수를 사용.

**공용체(Union)** : 구조체와의 차이는 구조체 안의 모든 멤버는 각기 다른 메모리를 차지하지만 공용체의 멤버들은 메모리를 공유할 수 있다.

---



## 단일 연결 리스트(Single linked list)

:a: **배열:** 물건 목록을 유지하는 가장 효율적인 방법. 실제 데이터만 저장하며 데이터 관리를 위한 부가 정보를 따로 요구하지 않음. 하지만 데이터 양이 정해져 있지 않은 경우에는 배열이 적합하지 않음

:link: **연결  리스트 :** 목록에 들어갈 원소 개수를 모르는 경우 배열보다 잘 작동. 단일 연결 리스트는 구조체 이용해 만들 수 있음

<img src="https://www.alphacodingskills.com/imgfiles/linked-list.PNG" style="zoom:67%;" />

* Next: 리스트의 다음 원소 주소를 저장하는 포인터

* Head: 리시트의 맨 앞
* Tail: 리스트의 마지막. 보통 NULL 포인터로 리스트 원소가 아님을 표현

리스트와 배열의 가장 큰 차이는 배열의 각 원소는 메모리에서 연속적으로 위치하지만, 리스트 원소는 메모리에서 아무 위치에나 있을 수 있다

* **원소 추가 :** 헤드 앞에 새 원소를 위치시킴. 

* **원소 삭제 :** 삭제할 리스트 원소의 바로 앞 원소의 next 포인터가 삭제할 원소의 next 포인터가 가리키는 원소를 가리키게 해야함

  * 한쌍의 포인터를 사용해 단일 연결 리스트의 원소 삭제. current 포인터는 삭제할 노드를 검색하면서 리스트의 각 원소 방문. previous 포인터를 통해 삭제할 노드 바로 앞 노드의 next 포인터를 조정할 수 있음. current.next는 현재 노드의 다음 노드를 가리키게 됨 --> 안 좋은 예

  ```c
  struct node {
      struct node* next;
      //데이터
  };
  struct node* head;
  struct node* node_to_delete;
  struct node* current;
  struct node* previous;
  
  previous = (struct node*)0;
  current = head;
  
  while (current != (struct node*)0) {
      if (current == node_to_delete) {
          if (previous == (struct node*)0)
              head = current->next;
          else
              previous->next = current->next;
          break;
      }
      else {
          previous = current;
          current = current->next;
      }
  }
  ```

  

  * 이중 간접 주소 지정(double indirect addressing) : 더 간단한 방법

    > ```c
    >                           entry -+
    >    head                          |
    >       +---+     +-------+     +-------+     +-------+     +-------+     +--------+
    >       |   |---->| 1 |   |--   | 2 |   |---->| 3 |   |---->| 4 |   |---->| 5 |NULL|
    >       +---+     +-------+  \  +-------+     +-------+     +-------+     +--------+
    >                   *indirect \              /
    >                              +------------+
    > //https://stackoverflow.com/questions/51794426/delete-an-entry-from-a-singly-linked-list
    > ```
    >
    > 제거할 노드 3이 나올 때까지 진행한다.
    >
    > 3번 노드를 제거한다고 할 때 우리는 2번 노드의 next 포인터를 다음 원소인 4번 노드를 가리키게 해야한다. current가 가리키고 있는 2.next를 3.next로 덮어쓴다. 3.next가 4를 가리키기 때문에 2.next는 이제 4를 가리키게 되었다.

  ```c
  struct node {
      struct node* next;
      //데이터
  };
  
  struct node* head;
  struct node* node_to_delete;
  struct node** current;
  
  for (current = &head; *current != (struct node*)0; current = &((*current)->next))
      if (*current == node_to_delete) {
          *current = node_to_delete->next;
          break;
      }
  } //짝이 안 맞는 거 같은데..?
  ```

  

## 동적 메모리 할당

위의 연결리스트에서 원소를 삽입하면서 새 노드를 위한 메모리를 어디서 얻는지는 설명하지 않았다.

:minidisc:**​ 동적 메모리 할당** : 프로그램 데이터 공간의 구성에서 정적으로 할당된 데이터 영역 다음에 프로그램 런타임 라이브러리가 설정해주는 힙 영역이 있다. 별도의 **메모리 관리 유닛(MMU, memory menagement unit)** 이 없는 컴퓨터라면 이 힙영역이 프로그램에 사용할 수 있는 모든 데이터 메모리이다. MMU가 있는 시스템에서는 런타임 라이브러리가 프로그램에 필요한 메모리 용량을 판단해 운영체제에 요청한다. 프로그램의 브레이크->프로그램이 사용할 수 있는 메모리의 끝

**정적 메모리:** 배열 등의 변수가 사용하는 메모리는 정적(static)이다. 이런 변수에 할당된 주소는 바뀌지 않는다.

**동적 메모리:** 리스트 노드와 같은 것은 동적이다. 이들은 필요에 따라 생기기도 사라지기도 한다. 이런 동적인 대상에 사용할 메모리를 **힙**에서 얻는다.

**C의 malloc과 free 함수**

* malloc 구현: (여기선 단일 연결 리스트 데이터 구조를 사용) 힙은 여러 블록으로 나뉘고 각 블록에는 크기와 다음 블록에 대한 포인터가 포함됨. 처음에는 전체 힙이 한 블록으로 존재함. 프로그램이 메모리를 요구하면 malloc이 충분한 크기의 블록을 찾아서 요청받은 공간에 대한 포인터를 돌려주고, 프로그램에게 할당한 메모리를 반영해 블록의 크기와 링크를 조절한다. 프로그램이 free로 메모리를 해제하면 메모리가 다시 연결 리스트에 추가된다.
* malloc은 종종 가용 블록을 스캔하면서 서로 인접한 경우 둘을 합쳐서 더 큰 블록으로 만든다. 시간이 지나면 메모리 공간은 파편화(fragmentation)된다. 이는 메모리를 모두 사용하지도 않았는데 너무 작은 가용 블록들만 남아서 malloc으로 요청받은 메모리를 돌려줄 수 없게 됐다는 뜻. MMU가 있는 시스템의 경우 더 큰 메모리를 얻기 위해 break를 조절할 수 있다.

**메모리 해제 문제**: 할당하지 않은 메모리를 해제하거나 해제된 메모리를 계속 사용함. 메모리 해제 후 포인터에 null값 할당해야함.

free 호출은 라이브러리 내부에서 해주는 메모리 해제를 의미. 사용자는 노드를 삭제하라는 요청만 내리면 되고, 컴파일러와 라이브러리가 알아서 메모리를 두 번 해제할지 한 번 만에 해제할지 결정



## 더 효율적인 메모리 할당

:dvd: ​문제: 텍스트 문자열이 들어 있는 연결 리스트의 경우 노드에 사용할 메모리도 할당해야 한다.

노드와 문자열을 동시에 할당하면 이런 부가 비용을 줄일 수 있다. 노드를 할당한 후 문자열을 할당하는 대신, 노드와 문자열의 크기를 합하고, 메모리 경계를 지키기 위해 필요한 패딩을 추가한 크기의 공간을 할당할 수 있다. 이 경우 노드를 할당한 메모리의 크기가 늘어다도 부가 비용을 반으로 줄여준다.



## 가비지 컬렉션(garbage collection)

**:put_litter_in_its_place: 가비지 컬렉션:** 자바나 자바스크립트처럼 포인터가 없는 언어에서 동적 메모리 할당의 방법으로 잘못된 포인터 사용 문제를 해결한다. (나쁜 포인터를 사용하면 프로그램이 오류로 중단됨)

**참조(reference)** : 포인터를 추상화해서 포인터와 비슷한 기능을 제공하지만 실제 메모리 주소를 노출하지는 않는다. 자바 같은 언어는 참조 사용

* 메모리 할당: new 연산자가 데이터 요소를 만들어내면서 이 요소가 사용할 메모리도 할당. 

* 메모리 해제: 데이터를 삭제시 언어의 런타임 환경이 변수 사용을 추적해서 더 이상 사용하지 않는 메모리를 자동으로 해제해준다

**가비지 컬렉션의 단점** : 프로그래머가 가비지 컬렉션 시스템을 제어할 수 없다. 불필요한 참조가 남으면 메모리 더 많이 사용하고 프로그램이 느려짐. 불필요한 참조를 추적하는 것도 디버깅이 어렵다



## 이중 연결 리스트(doubly linked list)

:chains: **이중 연결 리스트:** delete가 느린 단일 연결 리스트와 다르게, 이중 연결 리스트는 노드에 다음 원소에 대한 포인터뿐만 아니라 이전 원소에 대한 포인터도 들어 있는 리스트다. 노드당 부가 비용은 2배이지만 노드 삭제나 삽입 연산시 노드를 앞부터 방문할 필요가 없다. 즉 공간/시간의 트레이드 오프가 있다.



## 계층적인 데이터 구조

**:small_red_triangle: 계층적 데이터 구조 :** 순회하는 선형적인 데이터 구조와 다르게 데이터를 효율적으로 가져올 수 있다.

**2진 트리** : 노드가 최대 2개의 다른 노드와 연결될 수 있다. 간접 주소 지정을 활용해서 삽입, 삭제가 일어난다.

```c++
							  root    
                               |
                               8
                              / \
                             6   9
                            / \
                           4   5
```

8을 삽입할 떄 루트는 아무 노드도 가리키지 않는다. 따라서 새 노드를 만들고 루트가 이 노드를 가리키게 한다. 6을 삽입시에 8과 비교 후 왼쪽을 본다. 왼쪽 노드가 비어있으니 여기에 넣는다. 9는 8의 오른쪽으로 간다...이 알고리즘에선 트리를 변경할 필요가 없으므로 포인터는 필요 없다.

---



## 대용량 저장장치

**:cd: 디스크**의 기본 단위는 **블록**이고 연속적인 블록을 **클러스터**라고 부른다. 클러스터는 한 트랙 안에 있는 연속적인 섹터로 이루어지므로, 데이터를 한 클러스터에만 저장할 수 있으면 좋을 것이지만, 데이터가 큰 경우도 있고 일반적으로는 그리 바람직하지 않다. 대신에 데이터는 사용 가능한 섹터가 있으면 위치와 관계없이 저장된다.(저장이 연속적일 필요 없음)

어떤 데이터를 저장하기 위한 저장소 블록을 찾는 대신, 어떤 데이터를 저장하기에 충분한 크기가 되도록 고정된 크기의 블록을 여럿 확보해서 데이터를 이런 블록에 나눠 담아야 한다. 

데이터를 메모리상에서 관리할 때는 포인터를 통해 메모리를 참조해도 되지만, 장기적인 저장을 위해 디스크에 저장시 파일 이름을 통해 저장한다. 이 파일 이름을 디스크에 저장할 방법과 파일 이름과 파일의 데이터가 저장된 디스크 블록을 연결해줄 방법이 필요하다.

:information_desk_person: **아이노드** : ​이는 유닉스(UNIX)에서 나온 블록 중 일부를 **아이노드(inode)**로 따로 지정하는 방법을 이용해 해결 가능하다. 아이노드는 디스크 블록에 대한 인덱스(index)와 노드(node)를 합친 단어이다. 즉 인덱스 노드이다. 아이노드에는 파일 이름 등 여러 가지 정보가 들어간다. 아이노드는 보통 직접 블록(direct block) 포인터(실제로는 포인터가 아닌 블록의 인덱스)가 12개 있다. 파일이 더 커지면 간접 블록(indirect block)도 사용한다.

아이노드 정보 중에는 블록에 데이터가 있는지 디렉토리 정보가 있는지를 표시하는 것도 있으며 디렉토리는 파일 이름과 파일 데이터를 가리키는 아이노드를 연결해준다. 디렉터리가 다른 디렉터리를 참조하는 계층적 파일 시스템(hierarchical filesystem)이 생겨났다.

**심볼릭 링크(symbolic)** : 여러 아이노드가 같은 블록을 참조할 수 있는데 각 참조를 링크라고 부른다. 디렉터리에 대한 링크가 심볼릭 링크이다. 하지만 심볼릭 링크를 허용하면 파일 시스템 그래프에 루프가 생긴다. 이를 감지하기 위한 코드가 필요하다. 하지만 가용 공간(free space)을 추적하는 효율적인 방법이 아직 없다.

**가용공간 추적**을 위해 비트맵을 사용할 수 있다. 비트맵은 간단하면서 효율적이지만 파일 시스템 그래프와 가용 공간을 나타내는 비트맵 사이의 동기화가 깨질 수 있는 문제가 있다. **저널링(journaling) 파일 시스템**



## 데이터베이스

**🗄️ 데이터베이스** : 정해진 방식으로 방식으로 조직화된 데이터 모음이다. DBMS은 데이터베이스에 정보를 저장하고 읽어올 수 있게 해주는 프로그램이다.

:christmas_tree: **B트리**라는 데이터 구조를 활용한 시스템. B트리는 균형 트리이지만 2진 트리는 아니다. B트리는 균형 2진트리보다는 공간을 더 효율적으로 사용하지만 성능이 더 낫고, 특히 디스크에 데이터를 저장할 때 균형 2진 트리보다 성능이 좋다. 



## 인덱스

:label: 저장된 데이터에 접근할 때 인덱스를 이용하면 빠르게 검색할 수 있다. 주 인덱스(primary index)나 인덱스가 두 개 이상인 경우도 있다. 데이터 변경보다 데이터 검색이 더 자주 일어나기 때문에 인덱스 갱신 비용은 지불할 만한 비용이다. 



## 데이터 이동

**루프 언롤링(loop unrolling)** : 메모리를 0으로 설정하는 효율적인 구현

```c
									시작
                                     ↓
                current ← 0으로 설정할 메모리의 맨 앞 바이트 주소   
          ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━→ ↓
          ┃                      length > 0? -아니요 → 완료
          ┃                           ↓예
          ┃                   current가 가리키는 메모리  ← 0
          ┃                           ↓
          ┃                   current ← current + 1
          ┃                           ↓
          ┃                   current가 가리키는 메모리  ← 0   
          ┃                           ↓ 
          ┃                   current ← current + 1
          ┃                           ↓
          ┗━━━━━━━━━━━━━━━━━━━━  length ← lengh -2 

```



**더프의 장치(Duff's Device)**  :데이터 복사를 빠르게하기 위한 또 다른  메모리를 0으로 설정하는 방법. 루프를 펼치고 남은 바이트 수에 따라서 적당한 위치부터 펼친 루프의 단계를 시작한다.

복사를 구현할 때의 생기는 복잡한 문제 :

**블릿(blit)**: MMU가 없는 장치일 때 원본과 복사본의 주소를 고려해 복사를 빠르게 할 수 있는 최적의 코드를 그때그때 생성해내는 코드 작성. 이 방식은 자바 등 여러 언어의 가상 머신에서 사용 중인 기술인 JIT(just-in-time, 즉시 컴파일)의 선조라 할 수 이싸.



## 벡터를 사용한 I/O

시스템 성능에 있어 데이터를 효율적으로 복사하는 것이 중요하다. 하지만 복사를 아예 피할 수 있으면 성능을 더 높일 수 있다. 운영체제와 사용자 공간 프로그램 사이에는 데이터가 아주 많이 오고 간다. 이런 데이터가 연속적인 메모리에 위치하지 않는 경우도 자주 있다.

파일: **프레임(frame)**으로 구성되며, 각 프레임은 헤더(header)와 데이터로 구성됨

모든 데이터를를 한 버퍼로 복사해서 프레임을 만들 수도 있지만, 이 데이터를 오디오 등 장치에서 사용할 떄 또 한 번 데이터를 복사해야 한다. 시스템에 프레임의 각 부분을 가리키는 포인터의 집합을 전달하고 시스템이 데이터를 쓸 때 각 부분을 하나로 합쳐주면 더 효율적이다. 

**벡터를 사용한 I/O**: 크기와 데이터에 대한 포인터로 이뤄진 벡터를 운영 체제에 넘기면 이 벡터에 저장된 데이터를 사용해 순서대로 오디오 프레임을 조합한다. 데이터를 쓸 때와 읽을 때 모두 벡터를 사용할 수 있다. 벡터를 사용해 데이터를 쓰는 것은 **수집(gathering)**이라 하고, 데이터를 읽는 행위는 여러 위치로 데이터를 분산시키므로 **분산(scattering)**이라고 부른다. TCPT/IP에서 IP 데이터가 패킷으로 전달되고, TCP는 패킷이 올바른 순서로 전달되게 할 책임이 있다. 통신 종단점으로부터 도착하는 패킷은 사용자 프로그램에게 전달되기 전에 연속적인 스트림으로 수집된다.



## 객체 지향(object-oriented)의 함정

객체 지향 프로그래밍은 성능 문제가 발생할 수 있다. 객체 지향 프로그래밍은 C++를 통해 본격적으로 널리 사용되기 시작했다.

:o:객체에는 함수에 해당하는 **메서드(method)**와 데이터에 해당하는 **프로퍼티(property)**가 들어있다. 어떤 객체에 필요한 모든 데이터와 함수는 한 데이터 구조 안에 모여 있다. 

```c
객체
self : 자기 자신 포인팅
parent : 부모 객체 포인팅
constructor : struct object *new(){...}
destructor : void gozer(){...}
method1 : void method_1(){...}
method2
property1
property2
```

정숫값 등 크기가 작은 데이터를 저장하는 프로퍼티는 객체 구조 안에 들어가지만 메모리 할당이 더 필요한 프로퍼티는 객체 구조 안에 있는 포인터를 통해 참조된다. 매서드가 아주 많거나 하면 구조체가 아주 커질 수 있다. 이 때는 메서드를 별도의 데이터 구조에 나눠 담아서 문제를 해결할 수 있다.(시간/공간 트레이드 오프)

**객체 지향의 문제** : 객체는 전역적으로 알려진 함수 대신에 자신이 사용할 메서드에 대한 포인터를 가지고 다녀야 한다. 따라서 객체 내의 데이터가 데이터만 저장하는 데이터 구조처럼 꽉 짜여 있지 않다. 성능이 결정적으로 중요할 때는 전통적인 배열을 사용하자.



## 정렬

:alembic: ​정렬 대상이 포인터 크기보다 크다면 데이터를 직접 정렬하는 대신 데이터를 가리키는 포인터를 재배열하는 방식으로 정렬해서 데이터 자체가 여기저기로 움직이지 않게 해야 한다.

**퀵정렬(quicksort)을 구현한 qsort**: 이 함수는 데이터를 정렬하는 방법은 알지만 데이터를 비교하는 방법은 알지 못한다. 그래서 qsort는 C언어의 함수 포인터를 활용한다. qsort로 리스트를 정렬하려면 두 원소를 비교해서 더 작은 값을 돌려주는 함수를 가리키는 포인터를 함께 전달한다. 

**strcmp** : C언어의 문자열 비교 함수. 두 문자열을 비교하여 0보다 작은 정수, 0, 0보다 큰 정수 반환. 하지만 아스키 코드 기준으로 작성되었기에 다른 언어는 비교가 어려웠다.



## 해시

**해싱(hashing) :** 검색에 사용할 키에에 대해 이들을 균일하게 벽에 흩뿌려주는 **해시 함수**를 적용하는 것

해시 함수가 계산하기 쉽고 각 키를 벽에서 유일한 위치에 뿌려준다면, 검색을 아주 빠르게 할 수 있다. 해시 함수의 결괏값을 사용해 키에 대응하는 데이터를 메모리에 저장할 수 있다. 따라서 해시 함수는 메모리 크기보다 작은 범위의 값을 만들어내야 한다. 

**해시 테이블(hash table)**: 저장장치에 데이터를 저장하는 방법 중에는 해시 함수의 결과를 배열 인덱스로 활용하는 방법이 있다. 이런 배열을 해시 테이블이라고 한다. 이때 배열의 각 원소를 버킷(bucket)이라고 한다. 좋은 해시 함수는 계산하기 쉬워야 하고 키를 골고루 버킷에 뿌려줘야 한다 텍스트에 대해 잘 동작하는 해시 함수로는 문잣값을 모두 더하는 함수가 있다. 문잣값의 합계를 해시 테이블의 크기로 나누면 되고, 해시 테이블 크기를 소수(prime number)로 만들면 좋다.

**해시 충돌(hash collision)**: 해시 함수의 값이 같은 원소들이 있으면 해시 충돌이 일어난다. 이를 해결하기 위해 해시 체인(hash chain)을 사용한다.

**해시 체인:** 단일 연결 리스트 사용. 충돌이 일어나면 삽입을 빠르게 하기 위해 체인의 맨 앞에 우너소를 추가하거나 삽입 정렬로 해시 체인에 원소를 넣을 수도 있다. 

**완전 해시(perfect hash)** : 각 키를 유일한 버킷에 연결해주는 함수



## 효율성과 성능

컴퓨터 값이 극적으로 줄어든 현재는 성능과 효율이 분리되었다. 덜 효율적인 알고리즘이어도 더 많은 프로세서를 사용하면 더 나은 성능을 얻을 수도 있기 때문이다.

**데이터 베이스 샤딩(sharding)**: 샤딩은 성능과 효율이 분리된 상황을 응용하는 방법이다. 샤딩은 수평 파티셔닝(horizontal partitioning)이라고도 한다. 샤딩은 데이터베이스를 각각 다른 기계에서 실행되는 여러 샤드로 나누는 방식을 말한다. 

샤딩의 과정: 인터페이스를 통해 요청이 들어온 데이터베이스 연산을 모든 샤드에 전달하고, 컨트롤러가 결과를 하나로 모은다. 작업을 여러 작업자로 나누어 병렬적으로 실행할 수 있기에 성능이 향상된다.

샤딩의 변종으로 맵리듀스(MapReduce)가 있다. 맵리듀스는 근본적으로 컨트롤러가 중간 결과를 모으는 방법을 코드로 직접 작성할 수 있게 해준다. 
