---
layout: default
title: 한 권으로 읽는 컴퓨터 구조와 프로그래밍 3장
parent: 한 권으로 읽는 컴퓨터 구조와 프로그래밍
Grand_parent: Book Reviews
nav_order: 3


---





<img src="https://github.com/terri1102/terri1102.github.io/blob/master/assets/images/review/slp1.jpg?raw=true" alt="slp1" style="zoom:33%;" />

한 권으로 읽는 컴퓨터 구조와 프로그래밍

조너선 스타인하트 지음. 오현석 옮김. 책만



:toc



# 3장 메모리와 디스크의 핵심: 순차 논리

-컴퓨터는 비트를 어떻게 기억하는가?



## 순차논리(Sequential Logic)

2장에서 배운 '조합 논리'는 입력에 의해서만 출력이 결정된다. 조합 논리만으로는 연산의 부분결과를 기억해 둘 수 없기 때문에 `순차 논리`가 필요하다. 이런 순차 논리를 위해 디지털 회로에서 시간을 만들어내는 것이 필요해진다.



## 시간 표현과 상태기억

주기 함수를 이용해 시간을 측정할 수 있는 것처럼 컴퓨터는 '주기적'인 전기 신호를 이용해서 시간을 측정한다.



### 1. 발진자(Oscillator)

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/OpAmpHystereticOscillator.svg/1200px-OpAmpHystereticOscillator.svg.png" alt="oscillator" style="zoom:50%;" />

> 발진은 전기 신호를 자력에 의해 필요한 주파수로 진동시키는 일이다. 다시 말해서 직률 에너지를 전기진동 에너지, 즉 교류에너지로 변환하는 일이다.
>
> [^ ]: https://ko.wikipedia.org/wiki/%EB%B0%9C%EC%A7%84_(%EC%A0%84%EA%B8%B0%EA%B3%B5%ED%95%99)

인버터를 이용한 출력을 다시 입력에 넣는 것을 되먹임(feedback)이라고 하는데, 중간에 인버터를 거치기 때문에 출력값은 0과 1 사이를 진동한다(oscillate). 이 발진자를 사용하면 시간을 측정할 수 있다.



**수정 발진기(결정 진동자, crystal oscillator)**

<br>

> 정확한 발진자를 적은 비용으로 효율적으로 만드는 방법은 크리스탈을 활용하는 것이다. 전극(electrode, 전선)을 크리스털에 연결하고 크리스털을 압축하면 크리스털이 전기를 만들어낸다. 그리고 전극에 전기를 가하면 크리스털이 구부러진다. 이런 현상을 피에조 전기(piezoelectric, 압전) 효과라고 부른다.



### 2. 클록

시간이 중요한 (저수준의) 이유는 전파 지연이 회로가 작업을 수행하는 속도에 영향을 미치기 때문에 시간을 잴 수 있으면 결과가 안정적이고 올바르다고 확신할 수 있는 시점이 될 때까지 최악의 경우를 가정해 가산기의 지연시간을 기다릴 수 있다. 



진동의 개수를 세면 시간을 나타낼 수 있다. **클럭**이란 CPU의 속도를 나타내는 단위로 순차회로에 가해지는 진동의 속도를 나타내며 Hz로 표기한다. 클럭은 1초 동안 파장이 한 번 움직이는 시간을 의미하는데 이 시간 동안 처리하는 데이터 양에 따라 CPU의 속도가 달라지게 된다.



https://library.gabia.com/contents/infrahosting/1227/



발진자는 컴퓨터에 클럭(clock)을 제공한다. 회로의 최대 클럭 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정된다. 



> 컴퓨터 컴포넌트 제작에는 여러 통계가 필요하다. 컴포넌트를 이루는 부품들 사이에 편차가 크기 때문이다. 비닝(binning)과정은 부품을 측정해서 그 특성에 따라 여러 다른 빈이나 무더기로 분류한다. 지연 시간이 짧아서 빨리 반응할 수 있는 부품은 가장 가격이 높은 빈에 들어가고, 더 느리고 싼 부품은 다른 빈에 들어가며 이런 분류를 여러 단계의 빈을 사용해 반복한다. 부품 전체의 편차보다 더 작은 편차를 갖도록 부품을 빈에 나눠 담는다. 이런 이유로 부품의 전파 지연 시간을 표시할 때도 범위를 사용한다. 생산자는 전형적인 값과 함께 최솟값과 최댓값을 제공하는데 일반적인 논리 회로 설계 오류는 최댓값이나 최솟값을 사용하지 않고 전형적인 값을 사용하기에 생긴다.

오버 클로킹: 통계적으로 빈의 중간 정도에 위치하는 부품을 부품이 고장나지 않을 범위 안에서 클럭을 빠르게 공급하는 것.





### 3-1. 래치(Latch)

> **래치:** 빗장 같이 유지함. 클록은 스테이터스를 유지하는데는 적합하지 않음. 내가 필요한 신호에 유지가 필요한 경우일 때 로직을 적용해서 주기를 변경
>
> 입력 신호가 하이와 로우를 반복하더라도 출력은 하나로 유지할 수도 있다. 그래서 리셋이 들어와야지만 출력의 set을 clear 시킬 수 있다. (리셋을 통해서 래치를 풀 수 있다)



이제 시간을 표현했으니 정보를 1비트 기억할 방법을 생각해야 한다. OR 게이트의 출력을 되먹임하는 OR 게이트 래치는 반전이 없기 때문에 진동이 없어 출력이 하나의 값으로 유지된다. 되먹임을 끊고 회로를 재설정(reset)하기 위해 인버터를 단 AND-OR 게이트 래치가 사용된다. 

<img src="https://lh3.googleusercontent.com/proxy/KZAMjYbqWx_vHxzLavMPgiPPgkiQ3TAzwJD1yUJZGEsCIN1jZvRwpSUuzpx3xnhGTs9zpcxvGkuq6FC-El_TIDuauhxHwLPn1Hv-GT8KxmlT7jh-pq9GEbuhvM7DU3cXc7sT-PxCbxeAC2QzyR0-LnwAK01mbKwIFVqUqeUjVtI" style="zoom:70%;" />

> 위의 그림은 책에 있는 AND-OR 게이트 래치와 조금 다르게 생겼지만 비슷하게 작동한다. 위쪽의 input은 OR 게이트를 지나고 AND 게이트로 들어간다. 아래쪽의 input은 NOT 게이트를 거쳐 AND 게이트로 들어간다. 그리고 AND 게이트의 output은 OR gate로 되먹임된다. 예를들어 set의 input으로 1이 들어가면 output는 1, reset의 input이 1이면 output은 0이고 이 두 신호가 AND 게이트를 거친 output은 0이고 이는 OR 게이트를 거쳐 1로 나온다. 이 경우 output은 계속 1로 유지된다.????????????????(확인필요)

* **set**: 출력을 1로 설정(set)한다.

* **reset:** set을 clear한다. 출력을 0으로 설정한다.

* **반전(opposite)** : 하드웨어 기호 위에 선을 그어서 표현. 값이 0일 때 참이고 1일때 거짓인 액티브 로우를 표시한다.

* **액티브 하이, 액티브 로우**:  `액티브`는 출력 기준! `하이, 로우`는 입력 신호 기준!

  입력 신호가 high일 때 동작하게 할 수도 있고(액티브 하이), low일 떄 동작하게 할 수도 있음(액티브 로우)
  
  

**S-R 래치 :**

![s-r latch, nand gate](https://upload.wikimedia.org/wikipedia/commons/thumb/9/92/SR_Flip-flop_Diagram.svg/220px-SR_Flip-flop_Diagram.svg.png)



S-R 래치는 더 똑똑하게 1비트 메모리를 저장한다. S-R은 set-reset을  의미하는데 이들은 액티브 로우 입력을 받고 보수(complementary) 출력을 제공한다. 보수출력은 출력의 한쪽은 액티브 하이, 다른 쪽은 액티브 로우라는 뜻이다. 위의 그림은 NAND 게이트이고 아래 표는 위의 회로의 입출력을 보여준다.

| set_bar | reset_bar | Q    | Q_bar |
| ------- | --------- | ---- | ----- |
| ~~0~~   | ~~0~~     | ~~1~~ | ~~1~~ |
|0 | 1|1|0|
|1|0|0|1|
|1|1|memory|memory_bar|

set_bar와 reset_bar가 참(로우)인 경우는 두 출력이 모두 참이어서 보수 출력이 아니기 때문에 이런 입력은 사용하지 않는다. 두 입력이 모두 동시에 거짓(하이)로 바뀌는 경우에는 전파 지연 시간에 따라 출력이 달라지기 때문에 결과를 예측할 수 없다. 



S-R 래치는 AND-OR 게이트 래치와 다르게 설계가 대칭적이어서 set과 reset 신호의 지연 시간이 거의 비슷한 좋은 특성을 가진다.



**S-R 래치의 초깃값 설정**: set_bar와 reset_bar가 모두 1인 상태로 전원을 인간하면 Q의 초깃값을 알 수 없기 때문에 Q가 1이면 S NAND의 출력은 0, Q가 0이면 NAND의 출력은 1이다. 그래서 S NAND의 최초 출력값은 알 수 없기 때문에 S-R 래치의 초깃값을 알 수 없다. 순차 로직의 많은 구성요소는 이런 식으로 예측할 수 없는 초기 상태를 갖는 경우가 많다. 그래서 안정적인 동작을 우너한다면 초반에 전원을 인간하고 나서 우리가 알 수 있는 상태로 로직을 재설정하는 과정이 필요하다. 



### 3-2. 게이트가 있는 래치

어느 시점에 무언가를 기억하기 위해 게이트가 있는 래치를 사용한다. 그림을 보면 gate_bar입력이 거짓(하이)인 경우는 set_bar와 reset_bar가 어느 값이든 입력이 모두 1이기에 출력이 그대로 유지된다.

<br>

[게이트가 있는 S-R 래치]

![](https://www.electrical4u.com/wp-content/uploads/What-is-a-Gated-SR-Latch.png?ezimgfmt=ng%3Awebp%2Fngcb37%2Frs%3Adevice%2Frscb37-1)

이번 그림도 책과는 다르다...책에선 앞 부분이 OR 게이트인 NAND 래치였는데 여기는 NOR 래치인듯....


[^ ]: https://www.electrical4u.com/gated-s-r-latches-or-clocked-s-r-flip-flops/

[게이트가 있는 D 래치]

![](https://www.allaboutcircuits.com/uploads/articles/internal-logic-d-latch.jpg)

1비트 정보를 유지하고 싶기 때문에 위의 회로를 개선하기 위해 set_bar와 reset_bar를 같은 입력에 연결하면서 한쪽 입력에는 인버터를 추가해서 입력을 1비트만 받게 만들었다. 이 1비트 입력을 D라고 한다. 

이제 gate_bar가 참(로우)일 때 D가 1이면 Q출력이 1이 된다. 마찬가지로 gate_bar가 참일 때 D가 0이면 Q출력은 0이 된다. gate_bar가 거짓(하이)일 때는 D가 변해도 Q출력에 아무 영향이 없다.



Gated D latch의 문제: gate_bar가 참(로우)인 상태에서는 D의 변화가 그대로 출력에 나타나기 때문에 출력은 D의 상태에 따른 영향을 받게 된다. 이를 막기 위해 게이트를 여는 시간을 최소화 순간적으로 D의 상태에 맞춰 출력 상태를 변경할 수 있게 하면 좋을 것이다...



### 4. 플립플롭

플립플롭 또는 래치는 전자공학에서 1비트의 정보를 보관, 유지할 수 있는 회로이며 순차회로의 기본요소이다. 



**플립플롭과 래치의 차이:** 입력을 출력에 반영하는 시점을 클럭 신호의 순간 엣지에서 반영하는 플립플롭과, 입력에 따라 항상 반영되는 래치로 구분된다. 



> 게이트가 있는 래치 단락에서 논의했듯 데이터 변경으로 인해 잘못된 결과가 생길 가능성을 최소화하기 위해 일반적으로 사용하는 방법은 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것이다. 이런 전이를 **에지(edge)**라고 한다. 에지를 시간에 대한 판정 기준이라고 생각할 수 있다. 에지에 의해 데이터 변화가 촉발되는 래치(latch-triggered latch)를 플립플롭이라 부른다.





D 플립플롭

D는 데이터 또는 딜레이라고 함. 입력 D의 갑사을 클럭의 엣지에서 캡처해서 Q에 반영한다.엣지가 발생하지 않는 시간에는 Q가 변하지 않고 유지된다.



###### 위키피디아 https://ko.wikipedia.org/wiki/%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD



### 5. 카운터



### 6. 레지스터



CPU와 램의 속도 차이 때문에 CPU 안에 캐시 메모리를 만들어서 중요한 데이터만 저장해서 사용한다. CPU는 제일 빠른 L1 CACHE에서 데이터 요청하고, 없으면 L2, L3 CACHE에서 요청한 후 없으면 RAM에 요청한다. 



기억장치: 하드디스크, 램, 캐시메모리, 레지스터

레지스터: CPU 내부에서 데이터를 일시적으로 저장하는 장치로 가장 빠른 메모리.



**레지스터의 종류**

| | | |
| ---- | --------------- | -----|
|    100    |      프로그램 카운터            | 다음번에 수행할 메모리의 주소가 들어있음 |
| 100 | 메모리 주소 레지스터 | 프로그램 카운터에서 수행할 주소를 넘겨받은 다음에 그 주소를 찾아가 데이터를 가져오는 역할 |
|LOAD 10 | 메모리 버퍼 레지스터 | 메모리 주소 레지스터가 가져온 주소나 명령들을 일시적으로 저장한다. 이 중 명령은 명령어 레지스터로 이동되고, 연산에 사용될 데이터(피연산자)는 누산기 레지스터로 이동한다. |
| LOAD 10 | 명령어 레지스터 | 명령에 대한 데이터가 저장된다|


* 누산기 레지스터: 연산의 결과값이나 중간값을 일시적으로 저장. 누산기 레지스터에서 나온 최종 결과는 메모리 버퍼 레지스터를 통해 메모리로 전송된다

* 제어장치: 명렁어 레지스터에 있는 명령어를 받아 해석하고 해석된 명령을 실행할 시스템에 지시를 보내준다
* ALU : 산술 논리 연산 수행



**컴파일 과정의 예 **: 

컴파일 -> 어셈블리어 -> 기계어



[고급 언어]

C = A + B 

<br>

A와 B를 더해서 C에 저장한다



[어셈블리어]

<br>

LOAD [10] : 10번지에 있는 값을 읽어와서 <br>

ADD [11] : 11번지에 있는 연산을 수행한 다음 <br>

STORE [12] : 12번지에 저장한다 <br>



[기계어] <br>

16비트 언어 -> 램은 8비트이기 때문에 2줄로 저장됨. 32비트 4줄, 64비트는 8줄을 한번에 처리 가능.

<br>

100110 [0000001010] <br>

110011 [0000001011] <br>

111010 [0000001100] <br>



[전체적인 연산 프로세스] <br>

프로그램 카운터에서 주소를 가져오면 이 주소는 메모리 주소 레지스터로 전달된다. 메모리 주소 레지스터는 100번지에 있는 값을 가져와 메모리 버퍼 레지스터에 저장한다. 이렇게 메모리의 데이터를 CPU로 가져오는 과정을 인출이라고 한다. 명령어 레지스터로 명령어 LOAD가 이동하고 프로그램 카운터는 2 증가한다. (32비트 컴퓨터는 4 증가) 명령어 레지스터에 저장된 명령어는 제어장치로 이동되어서 해석된다. 이 과정을 해석 단계라고 한다. 제어장치에서 메모리 주소 레지스터를 통해 값을 읽어온 다음 이를 메모리 버퍼 레지스터에 저장한다. 명령어가 아닌 데이터는 누산기 레지스터에 저장된다. 이제 다음 줄 처리. 더하기 명령을 실행하기 위해 누산기 레지스터에 저장된 값은 ALU로 전달된다.... ALU의 연산 결과는 누산기에 저장된다. 산술 논리 장치에서 계산되는 과정을 실행이라고 한다. 







---



## 메모리 조직과 주소 지정

* 트라이스테이트
* 







